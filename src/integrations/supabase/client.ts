
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { debugSupabaseClient } from '@/utils/authDebug';

const SUPABASE_URL = "https://bnulocsnxiffavvabfdj.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJudWxvY3NueGlmZmF2dmFiZmRqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA4NzM1NTMsImV4cCI6MjA2NjQ0OTU1M30.3QeKQtbvTN4KQboUKhqOov16HZvz-xVLxmhl70S2IAE";

// Singleton pattern: Uma √∫nica inst√¢ncia do cliente Supabase para toda a aplica√ß√£o
let supabaseInstance: ReturnType<typeof createClient<Database>> | null = null;

// Fun√ß√£o para obter a inst√¢ncia √∫nica do cliente Supabase com configura√ß√£o otimizada
const getSupabaseInstance = () => {
  if (!supabaseInstance) {
    console.log('üîß [Supabase] Creating optimized client instance with robust session handling');
    supabaseInstance = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true,
        // Configura√ß√£o espec√≠fica para garantir hidrata√ß√£o imediata
        storage: typeof window !== 'undefined' ? window.localStorage : undefined,
        storageKey: 'sb-bnulocsnxiffavvabfdj-auth-token', // Chave espec√≠fica do projeto
        flowType: 'pkce',
        debug: true, // Habilitar debug para diagnosticar problemas de hidrata√ß√£o
      },
      global: {
        headers: {
          'x-client-info': 'supabase-js-web/2.50.2'
        },
      },
    });
    
    debugSupabaseClient();
  }
  return supabaseInstance;
};

export const supabase = getSupabaseInstance();

// Fun√ß√£o CR√çTICA para garantir hidrata√ß√£o robusta na inicializa√ß√£o
export const ensureSessionHydration = async (): Promise<boolean> => {
  try {
    console.log('üîç [ensureSessionHydration] Iniciando hidrata√ß√£o robusta da sess√£o...');
    
    // Primeira tentativa: getSession() imediato
    const { data: { session }, error } = await supabase.auth.getSession();
    
    if (error) {
      console.error('‚ùå [ensureSessionHydration] Erro ao obter sess√£o:', error);
      return false;
    }
    
    if (session?.access_token) {
      console.log('‚úÖ [ensureSessionHydration] Sess√£o hidratada com sucesso');
      console.log('üîç [ensureSessionHydration] Token present:', session.access_token.substring(0, 20) + '...');
      return true;
    }
    
    // Segunda tentativa: verificar localStorage diretamente
    if (typeof window !== 'undefined') {
      const storageKey = 'sb-bnulocsnxiffavvabfdj-auth-token';
      const storedSession = window.localStorage.getItem(storageKey);
      
      if (storedSession) {
        console.log('üîç [ensureSessionHydration] Token encontrado no localStorage, tentando refresh...');
        
        // Tentar refresh da sess√£o
        const { data: refreshData, error: refreshError } = await supabase.auth.refreshSession();
        
        if (refreshError) {
          console.error('‚ùå [ensureSessionHydration] Erro no refresh:', refreshError);
          return false;
        }
        
        if (refreshData.session) {
          console.log('‚úÖ [ensureSessionHydration] Sess√£o restaurada via refresh');
          return true;
        }
      }
    }
    
    console.warn('‚ö†Ô∏è [ensureSessionHydration] Nenhuma sess√£o v√°lida encontrada');
    return false;
    
  } catch (error) {
    console.error('‚ùå [ensureSessionHydration] Erro inesperado:', error);
    return false;
  }
};

// Fun√ß√£o para validar JWT com diagn√≥stico aprimorado
export const getValidSession = async () => {
  try {
    console.log('üîç [getValidSession] Iniciando valida√ß√£o com diagn√≥stico aprimorado...');
    
    const { data: { session }, error } = await supabase.auth.getSession();
    
    if (error) {
      console.error('‚ùå [getValidSession] Erro ao obter sess√£o:', error);
      return null;
    }
    
    if (!session) {
      console.warn('‚ö†Ô∏è [getValidSession] Nenhuma sess√£o encontrada');
      
      // Diagn√≥stico adicional
      if (typeof window !== 'undefined') {
        const storageKey = 'sb-bnulocsnxiffavvabfdj-auth-token';
        const hasStoredData = !!window.localStorage.getItem(storageKey);
        console.log('üîç [getValidSession] LocalStorage tem dados:', hasStoredData);
      }
      
      return null;
    }
    
    // VALIDA√á√ÉO CR√çTICA: Analisar o JWT payload
    if (session.access_token) {
      try {
        const jwtPayload = JSON.parse(atob(session.access_token.split('.')[1]));
        
        console.log('üîç [getValidSession] JWT Payload Analysis:', {
          role: jwtPayload.role,
          sub: jwtPayload.sub,
          email: jwtPayload.email,
          exp: jwtPayload.exp,
          iat: jwtPayload.iat,
          aud: jwtPayload.aud,
          tokenValid: jwtPayload.exp > Math.floor(Date.now() / 1000)
        });
        
        // VERIFICA√á√ÉO 1: Token deve ser authenticated
        if (jwtPayload.role !== 'authenticated') {
          console.error('‚ùå [getValidSession] Token n√£o √© authenticated:', jwtPayload.role);
          await supabase.auth.signOut();
          return null;
        }
        
        // VERIFICA√á√ÉO 2: Token deve ter user_id (sub)
        if (!jwtPayload.sub) {
          console.error('‚ùå [getValidSession] Token sem user_id (sub)');
          await supabase.auth.signOut();
          return null;
        }
        
        // VERIFICA√á√ÉO 3: Token n√£o pode estar expirado
        const now = Math.floor(Date.now() / 1000);
        if (jwtPayload.exp <= now) {
          console.warn('‚ö†Ô∏è [getValidSession] Token expirado, tentando refresh...');
          const refreshResult = await supabase.auth.refreshSession();
          
          if (refreshResult.error || !refreshResult.data.session) {
            console.error('‚ùå [getValidSession] Erro no refresh:', refreshResult.error);
            await supabase.auth.signOut();
            return null;
          }
          
          console.log('‚úÖ [getValidSession] Token renovado com sucesso');
          return refreshResult.data.session;
        }
        
        console.log('‚úÖ [getValidSession] Token authenticated v√°lido confirmado');
        
      } catch (parseError) {
        console.error('‚ùå [getValidSession] Erro ao analisar JWT:', parseError);
        await supabase.auth.signOut();
        return null;
      }
    }
    
    return session;
  } catch (error) {
    console.error('‚ùå [getValidSession] Erro inesperado:', error);
    return null;
  }
};

// Fun√ß√£o para verificar se o usu√°rio est√° autenticado
export const isUserAuthenticated = async () => {
  const session = await getValidSession();
  return !!session;
};

// Fun√ß√£o para obter headers de autentica√ß√£o v√°lidos com diagn√≥stico
export const getAuthHeaders = async () => {
  const session = await getValidSession();
  
  if (!session?.access_token) {
    console.error('‚ùå [getAuthHeaders] Token authenticated n√£o dispon√≠vel');
    return {};
  }
  
  const headers = {
    'Authorization': `Bearer ${session.access_token}`,
    'apikey': SUPABASE_PUBLISHABLE_KEY,
    'Content-Type': 'application/json'
  };
  
  console.log('‚úÖ [getAuthHeaders] Headers com token authenticated preparados');
  return headers;
};

// Sistema simplificado de gerenciamento de contexto para cart√≥rios
class CartorioAuthManager {
  private currentToken: string | null = null;

  setContext(token: string) {
    console.log('üîê [CartorioAuth] Configurando contexto para token:', token.substring(0, 20) + '...');
    this.currentToken = token;
  }

  clearContext() {
    console.log('üîê [CartorioAuth] Limpando contexto');
    this.currentToken = null;
  }

  hasValidContext(): boolean {
    return this.currentToken !== null;
  }
}

const cartorioAuthManager = new CartorioAuthManager();

export const setCartorioAuthContext = (token: string) => {
  cartorioAuthManager.setContext(token);
};

export const clearCartorioAuthContext = () => {
  cartorioAuthManager.clearContext();
};

// Fun√ß√£o para executar RPC com valida√ß√£o robusta de sess√£o
export const executeRPCWithCartorioContext = async (rpcName: string, params: any) => {
  console.log(`üîÑ [executeRPC] Executando ${rpcName} com valida√ß√£o robusta...`);
  
  try {
    // Garantir que temos uma sess√£o v√°lida antes de executar
    const session = await getValidSession();
    
    if (!session) {
      console.error(`‚ùå [executeRPC] Sess√£o inv√°lida para ${rpcName}`);
      throw new Error('Sess√£o inv√°lida. Fa√ßa login novamente.');
    }
    
    console.log(`üîç [executeRPC] Executando ${rpcName} com sess√£o v√°lida`);
    
    const { data, error } = await supabase.rpc(rpcName as any, params);
    
    if (error) {
      console.error(`‚ùå [executeRPC] Erro RPC ${rpcName}:`, error);
      throw error;
    }
    
    console.log(`‚úÖ [executeRPC] ${rpcName} executado com sucesso`);
    return data;
  } catch (rpcError) {
    console.error(`‚ùå [executeRPC] Falha na execu√ß√£o de ${rpcName}:`, rpcError);
    throw rpcError;
  }
};
