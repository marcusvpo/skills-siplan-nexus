
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { debugSupabaseClient } from '@/utils/authDebug';

const SUPABASE_URL = "https://bnulocsnxiffavvabfdj.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJudWxvY3NueGlmZmF2dmFiZmRqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA4NzM1NTMsImV4cCI6MjA2NjQ0OTU1M30.3QeKQtbvTN4KQboUKhqOov16HZvz-xVLxmhl70S2IAE";

// Singleton pattern: Uma √∫nica inst√¢ncia do cliente Supabase para toda a aplica√ß√£o
let supabaseInstance: ReturnType<typeof createClient<Database>> | null = null;

// Fun√ß√£o para obter a inst√¢ncia √∫nica do cliente Supabase
const getSupabaseInstance = () => {
  if (!supabaseInstance) {
    console.log('üîß [Supabase] Creating single client instance');
    supabaseInstance = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true,
        storage: typeof window !== 'undefined' ? window.localStorage : undefined,
        storageKey: 'supabase.auth.token',
      },
      global: {
        headers: {
          'x-client-info': 'supabase-js-web/2.50.2'
        },
      },
    });
    
    debugSupabaseClient();
  }
  return supabaseInstance;
};

export const supabase = getSupabaseInstance();

// Export for backward compatibility
export const createAuthenticatedClient = (token?: string) => {
  return supabase;
};

// Fun√ß√£o cr√≠tica para validar JWT e garantir token authenticated
export const getValidSession = async () => {
  try {
    console.log('üîç [getValidSession] Iniciando valida√ß√£o de sess√£o...');
    
    const { data: { session }, error } = await supabase.auth.getSession();
    
    if (error) {
      console.error('‚ùå [getValidSession] Erro ao obter sess√£o:', error);
      return null;
    }
    
    if (!session) {
      console.warn('‚ö†Ô∏è [getValidSession] Nenhuma sess√£o encontrada');
      return null;
    }
    
    // VALIDA√á√ÉO CR√çTICA: Analisar o JWT payload
    if (session.access_token) {
      try {
        const jwtPayload = JSON.parse(atob(session.access_token.split('.')[1]));
        console.log('üîç [getValidSession] JWT Payload Analysis:', {
          role: jwtPayload.role,
          sub: jwtPayload.sub,
          email: jwtPayload.email,
          exp: jwtPayload.exp,
          iat: jwtPayload.iat,
          aud: jwtPayload.aud
        });
        
        // VERIFICA√á√ÉO 1: Token deve ser authenticated
        if (jwtPayload.role !== 'authenticated') {
          console.error('‚ùå [getValidSession] Token n√£o √© authenticated:', jwtPayload.role);
          console.error('‚ùå [getValidSession] Token an√¥nimo detectado - for√ßando logout');
          await supabase.auth.signOut();
          return null;
        }
        
        // VERIFICA√á√ÉO 2: Token deve ter user_id (sub)
        if (!jwtPayload.sub) {
          console.error('‚ùå [getValidSession] Token sem user_id (sub)');
          await supabase.auth.signOut();
          return null;
        }
        
        // VERIFICA√á√ÉO 3: Token n√£o pode estar expirado
        const now = Math.floor(Date.now() / 1000);
        if (jwtPayload.exp <= now) {
          console.warn('‚ö†Ô∏è [getValidSession] Token expirado, tentando refresh...');
          const refreshResult = await supabase.auth.refreshSession();
          
          if (refreshResult.error || !refreshResult.data.session) {
            console.error('‚ùå [getValidSession] Erro no refresh:', refreshResult.error);
            await supabase.auth.signOut();
            return null;
          }
          
          console.log('‚úÖ [getValidSession] Token renovado com sucesso');
          return refreshResult.data.session;
        }
        
        console.log('‚úÖ [getValidSession] Token authenticated v√°lido confirmado');
        console.log('‚úÖ [getValidSession] User ID:', jwtPayload.sub);
        console.log('‚úÖ [getValidSession] Email:', jwtPayload.email);
        
      } catch (parseError) {
        console.error('‚ùå [getValidSession] Erro ao analisar JWT:', parseError);
        await supabase.auth.signOut();
        return null;
      }
    }
    
    return session;
  } catch (error) {
    console.error('‚ùå [getValidSession] Erro inesperado:', error);
    return null;
  }
};

// Fun√ß√£o para verificar se o usu√°rio est√° autenticado com token v√°lido
export const isUserAuthenticated = async () => {
  const session = await getValidSession();
  return !!session;
};

// Fun√ß√£o para obter headers de autentica√ß√£o v√°lidos
export const getAuthHeaders = async () => {
  const session = await getValidSession();
  
  if (!session?.access_token) {
    console.error('‚ùå [getAuthHeaders] Token authenticated n√£o dispon√≠vel');
    return {};
  }
  
  const headers = {
    'Authorization': `Bearer ${session.access_token}`,
    'apikey': SUPABASE_PUBLISHABLE_KEY,
    'Content-Type': 'application/json'
  };
  
  console.log('‚úÖ [getAuthHeaders] Headers com token authenticated preparados');
  return headers;
};

// Sistema simplificado de gerenciamento de contexto para cart√≥rios
class CartorioAuthManager {
  private currentToken: string | null = null;

  setContext(token: string) {
    console.log('üîê [CartorioAuth] Configurando contexto para token:', token.substring(0, 20) + '...');
    this.currentToken = token;
  }

  clearContext() {
    console.log('üîê [CartorioAuth] Limpando contexto');
    this.currentToken = null;
  }

  hasValidContext(): boolean {
    return this.currentToken !== null;
  }
}

const cartorioAuthManager = new CartorioAuthManager();

export const setCartorioAuthContext = (token: string) => {
  cartorioAuthManager.setContext(token);
};

export const clearCartorioAuthContext = () => {
  cartorioAuthManager.clearContext();
};

// Fun√ß√£o para executar RPC com contexto de cart√≥rio - SEM INVALIDAR SESS√ÉO
export const executeRPCWithCartorioContext = async (rpcName: string, params: any) => {
  console.log(`üîÑ [executeRPC] Executando ${rpcName} com sess√£o atual...`);
  
  try {
    // USAR SESS√ÉO ATUAL SEM VALIDA√á√ïES QUE POSSAM INVALID√Å-LA
    const { data, error } = await supabase.rpc(rpcName as any, params);
    
    if (error) {
      console.error(`‚ùå [executeRPC] Erro RPC ${rpcName}:`, error);
      throw error;
    }
    
    console.log(`‚úÖ [executeRPC] ${rpcName} executado com sucesso`);
    return data;
  } catch (rpcError) {
    console.error(`‚ùå [executeRPC] Falha na execu√ß√£o de ${rpcName}:`, rpcError);
    throw rpcError;
  }
};
