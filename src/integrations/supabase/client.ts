
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { debugSupabaseClient } from '@/utils/authDebug';

const SUPABASE_URL = "https://bnulocsnxiffavvabfdj.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJudWxvY3NueGlmZmF2dmFiZmRqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA4NzM1NTMsImV4cCI6MjA2NjQ0OTU1M30.3QeKQtbvTN4KQboUKhqOov16HZvz-xVLxmhl70S2IAE";

// Singleton pattern: Uma √∫nica inst√¢ncia do cliente Supabase para toda a aplica√ß√£o
let supabaseInstance: ReturnType<typeof createClient<Database>> | null = null;

// Fun√ß√£o para obter a inst√¢ncia √∫nica do cliente Supabase
const getSupabaseInstance = () => {
  if (!supabaseInstance) {
    console.log('üîß [Supabase] Creating single client instance');
    supabaseInstance = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
      auth: {
        persistSession: true, // Mant√©m a sess√£o persistente
        autoRefreshToken: true, // Auto-refresh de tokens
        detectSessionInUrl: true,
        storage: typeof window !== 'undefined' ? window.localStorage : undefined,
        storageKey: 'supabase.auth.token',
      },
      global: {
        headers: {
          'x-client-info': 'supabase-js-web/2.50.2'
        },
      },
    });
    
    // Debug apenas em desenvolvimento
    debugSupabaseClient();
  }
  return supabaseInstance;
};

// Export da inst√¢ncia √∫nica
export const supabase = getSupabaseInstance();

// Fun√ß√£o para validar JWT e obter sess√£o v√°lida
export const getValidSession = async () => {
  try {
    const { data: { session }, error } = await supabase.auth.getSession();
    
    if (error) {
      console.error('‚ùå [getValidSession] Erro ao obter sess√£o:', error);
      return null;
    }
    
    if (!session) {
      console.warn('‚ö†Ô∏è [getValidSession] Nenhuma sess√£o encontrada');
      return null;
    }
    
    // DEBUG: Analisar o JWT payload
    if (session.access_token) {
      try {
        const jwtPayload = JSON.parse(atob(session.access_token.split('.')[1]));
        console.log('üîç [getValidSession] JWT Payload:', {
          role: jwtPayload.role,
          sub: jwtPayload.sub,
          email: jwtPayload.email,
          exp: jwtPayload.exp,
          iat: jwtPayload.iat
        });
        
        // Verificar se o token √© authenticated
        if (jwtPayload.role === 'anon') {
          console.error('‚ùå [getValidSession] Token an√¥nimo detectado - usu√°rio n√£o autenticado');
          return null;
        }
        
        if (jwtPayload.role !== 'authenticated') {
          console.error('‚ùå [getValidSession] Token com role inv√°lida:', jwtPayload.role);
          return null;
        }
        
        if (!jwtPayload.sub) {
          console.error('‚ùå [getValidSession] Token sem user_id (sub)');
          return null;
        }
        
        console.log('‚úÖ [getValidSession] Token authenticated v√°lido para user:', jwtPayload.sub);
      } catch (parseError) {
        console.error('‚ùå [getValidSession] Erro ao analisar JWT:', parseError);
        return null;
      }
    }
    
    // Verificar se a sess√£o n√£o expirou
    const now = Math.floor(Date.now() / 1000);
    const expiresAt = session.expires_at || 0;
    
    if (expiresAt <= now) {
      console.warn('‚ö†Ô∏è [getValidSession] Sess√£o expirada, tentando refresh');
      
      // Tentar refresh da sess√£o
      const { data: { session: refreshedSession }, error: refreshError } = await supabase.auth.refreshSession();
      
      if (refreshError || !refreshedSession) {
        console.error('‚ùå [getValidSession] Erro no refresh da sess√£o:', refreshError);
        return null;
      }
      
      // Verificar novamente o JWT ap√≥s refresh
      if (refreshedSession.access_token) {
        try {
          const jwtPayload = JSON.parse(atob(refreshedSession.access_token.split('.')[1]));
          console.log('üîç [getValidSession] JWT Payload ap√≥s refresh:', {
            role: jwtPayload.role,
            sub: jwtPayload.sub,
            email: jwtPayload.email
          });
          
          if (jwtPayload.role !== 'authenticated') {
            console.error('‚ùå [getValidSession] Token refreshed ainda n√£o √© authenticated');
            return null;
          }
        } catch (parseError) {
          console.error('‚ùå [getValidSession] Erro ao analisar JWT refreshed:', parseError);
          return null;
        }
      }
      
      console.log('‚úÖ [getValidSession] Sess√£o renovada com sucesso');
      return refreshedSession;
    }
    
    console.log('‚úÖ [getValidSession] Sess√£o v√°lida encontrada');
    return session;
  } catch (error) {
    console.error('‚ùå [getValidSession] Erro inesperado:', error);
    return null;
  }
};

// Fun√ß√£o para verificar se o usu√°rio est√° autenticado com token v√°lido
export const isUserAuthenticated = async () => {
  const session = await getValidSession();
  return !!session;
};

// Fun√ß√£o para obter headers de autentica√ß√£o v√°lidos
export const getAuthHeaders = async () => {
  const session = await getValidSession();
  
  if (!session?.access_token) {
    console.error('‚ùå [getAuthHeaders] N√£o foi poss√≠vel obter token v√°lido');
    return {};
  }
  
  const headers = {
    'Authorization': `Bearer ${session.access_token}`,
    'apikey': SUPABASE_PUBLISHABLE_KEY,
    'Content-Type': 'application/json'
  };
  
  console.log('‚úÖ [getAuthHeaders] Headers de autentica√ß√£o preparados');
  return headers;
};

// Sistema de gerenciamento de contexto de autentica√ß√£o para cart√≥rios
class AuthContextManager {
  private currentToken: string | null = null;
  private currentHeaders: Record<string, string> = {};

  setCartorioContext(token: string) {
    console.log('üîê [AuthContext] Setting cartorio context with token type:', token.startsWith('CART-') ? 'CART token' : 'Other token');
    
    this.currentToken = token;
    this.currentHeaders = {};
    
    // Para tokens de cart√≥rio, configurar headers customizados
    if (token.startsWith('CART-')) {
      this.currentHeaders = {
        'Authorization': `Bearer ${token}`,
        'X-Custom-Auth': token,
      };
    } else {
      this.currentHeaders = {
        'Authorization': `Bearer ${token}`,
      };
    }
  }

  clearContext() {
    console.log('üîê [AuthContext] Clearing cartorio context');
    this.currentToken = null;
    this.currentHeaders = {};
  }

  getHeaders(): Record<string, string> {
    return { ...this.currentHeaders };
  }

  hasContext(): boolean {
    return this.currentToken !== null;
  }

  getCurrentToken(): string | null {
    return this.currentToken;
  }
}

// Inst√¢ncia √∫nica do gerenciador de contexto
const authContextManager = new AuthContextManager();

// Fun√ß√£o para configurar o contexto de autentica√ß√£o de cart√≥rio
export const setCartorioAuthContext = (token: string) => {
  authContextManager.setCartorioContext(token);
};

// Fun√ß√£o para limpar o contexto de autentica√ß√£o de cart√≥rio
export const clearCartorioAuthContext = () => {
  authContextManager.clearContext();
};

// Fun√ß√£o para obter cliente com contexto de autentica√ß√£o apropriado
export const getAuthenticatedClient = () => {
  // Sempre retorna a inst√¢ncia √∫nica do cliente Supabase
  // O contexto de cart√≥rio √© gerenciado via headers nas Edge Functions
  return getSupabaseInstance();
};

// Helper function compat√≠vel com o c√≥digo existente
export const createAuthenticatedClient = (token: string) => {
  console.log('üîê [createAuthenticatedClient] Setting up context for token type:', token.startsWith('CART-') ? 'CART token' : 'Other token');
  
  // Em vez de criar nova inst√¢ncia, configuramos o contexto
  setCartorioAuthContext(token);
  
  // Retorna a inst√¢ncia √∫nica configurada
  return getAuthenticatedClient();
};

// Fun√ß√µes de compatibilidade (mantidas para n√£o quebrar c√≥digo existente)
export const setCustomAuthToken = (token: string) => {
  console.log('Setting custom auth token via compatibility function:', token);
  setCartorioAuthContext(token);
};

export const clearCustomAuthToken = () => {
  console.log('Clearing custom auth token via compatibility function');
  clearCartorioAuthContext();
};
