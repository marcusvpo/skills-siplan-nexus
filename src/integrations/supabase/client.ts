
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { debugSupabaseClient } from '@/utils/authDebug';
import { customCartorioStorage } from '@/utils/customSupabaseStorage';

const SUPABASE_URL = "https://bnulocsnxiffavvabfdj.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJudWxvY3NueGlmZmF2dmFiZmRqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA4NzM1NTMsImV4cCI6MjA2NjQ0OTU1M30.3QeKQtbvTN4KQboUKhqOov16HZvz-xVLxmhl70S2IAE";

// Singleton pattern: Uma √∫nica inst√¢ncia do cliente Supabase para toda a aplica√ß√£o
let supabaseInstance: ReturnType<typeof createClient<Database>> | null = null;

// ‚≠ê FUN√á√ÉO DE DEBUG CR√çTICA - Vamos descobrir qual chave est√° sendo usada
const debugStorageKeys = () => {
  console.log('üîç [DEBUG] === DIAGN√ìSTICO COMPLETO DE STORAGE ===');
  
  // Todas as chaves no localStorage
  const allLocalStorageKeys = Object.keys(localStorage);
  console.log('üîë [DEBUG] TODAS as chaves localStorage:', allLocalStorageKeys);
  
  // Chaves relacionadas a auth/supabase
  const authKeys = allLocalStorageKeys.filter(key => 
    key.includes('auth') || 
    key.includes('token') || 
    key.includes('supabase') || 
    key.includes('sb-')
  );
  console.log('üîê [DEBUG] Chaves AUTH encontradas:', authKeys);
  
  // Valores dessas chaves
  authKeys.forEach(key => {
    const value = localStorage.getItem(key);
    console.log(`üì¶ [DEBUG] ${key}:`, value ? 'TEM VALOR' : 'NULL', value?.substring(0, 100) + '...');
  });
  
  console.log('üîç [DEBUG] === FIM DO DIAGN√ìSTICO ===');
};

// Fun√ß√£o para obter a inst√¢ncia √∫nica do cliente Supabase com configura√ß√£o otimizada
const getSupabaseInstance = () => {
  if (!supabaseInstance) {
    console.log('üîß [Supabase] Criando inst√¢ncia otimizada do cliente com storage customizado');
    
    // Debug antes de criar o cliente
    debugStorageKeys();
    
    supabaseInstance = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
      auth: {
        storage: customCartorioStorage, // ‚≠ê STORAGE CUSTOMIZADO COM DEBUG
        storageKey: 'sb-cartorio-auth-token', // ‚≠ê CHAVE ESPEC√çFICA
        autoRefreshToken: true,
        persistSession: true,
        detectSessionInUrl: false, // Alterado para false para evitar conflitos
        flowType: 'pkce',
        debug: true, // ‚≠ê DEBUG HABILITADO
      },
      realtime: {
        params: {
          eventsPerSecond: 10
        }
      },
      global: {
        headers: {
          'X-Client-Info': 'cartorio-app-debug'
        }
      }
    });
    
    // ‚≠ê DIAGN√ìSTICO CONT√çNUO E DETALHADO
    supabaseInstance.auth.onAuthStateChange((event, session) => {
      console.log(`üîÑ [Supabase] Auth event: ${event}`, {
        hasSession: !!session,
        hasAccessToken: !!session?.access_token,
        hasRefreshToken: !!session?.refresh_token, // ‚≠ê ADICIONADO DEBUG DO REFRESH TOKEN
        expiresAt: session?.expires_at,
        userId: session?.user?.id,
        tokenPreview: session?.access_token?.substring(0, 30) + '...',
        refreshTokenPreview: session?.refresh_token?.substring(0, 30) + '...' // ‚≠ê PREVIEW DO REFRESH TOKEN
      });
      
      // Debug storage ap√≥s cada evento
      if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
        console.log('üîç [Supabase] Verificando storage ap√≥s', event);
        setTimeout(() => debugStorageKeys(), 100);
      }
    });
    
    debugSupabaseClient();
  }
  return supabaseInstance;
};

export const supabase = getSupabaseInstance();

// ‚≠ê FUN√á√ÉO CR√çTICA PARA SINCRONIZAR TOKENS DE CHAVES PADR√ÉO PARA CUSTOMIZADA
export const syncTokensToCustomKey = async (): Promise<void> => {
  console.log('üîÑ [syncTokensToCustomKey] Sincronizando tokens de chaves padr√£o para customizada...');
  
  const defaultKeys = [
    'supabase.auth.token',
    'sb-bnulocsnxiffavvabfdj-auth-token',
    'sb-auth-token'
  ];
  
  for (const key of defaultKeys) {
    const value = localStorage.getItem(key);
    if (value) {
      console.log(`üîç [syncTokensToCustomKey] Chave padr√£o encontrada: ${key}`);
      try {
        customCartorioStorage.setItem('sb-cartorio-auth-token', value);
        console.log('‚úÖ [syncTokensToCustomKey] Token sincronizado para chave customizada');
        return; // Encontrou e sincronizou, pode parar
      } catch (error) {
        console.error('‚ùå [syncTokensToCustomKey] Erro ao sincronizar token:', error);
      }
    }
  }
  
  console.log('‚ö†Ô∏è [syncTokensToCustomKey] Nenhum token encontrado nas chaves padr√£o');
};

// ‚≠ê FUN√á√ÉO CR√çTICA PARA GARANTIR HIDRATA√á√ÉO ROBUSTA NA INICIALIZA√á√ÉO
export const ensureSessionHydration = async (): Promise<boolean> => {
  try {
    console.log('üîç [ensureSessionHydration] === INICIANDO HIDRATA√á√ÉO ROBUSTA ===');
    
    // 1. Debug completo do storage antes de tentar hidratar
    debugStorageKeys();
    
    // 2. Sincronizar tokens de chaves padr√£o para customizada
    await syncTokensToCustomKey();
    
    // 3. Verificar se nossa chave customizada existe agora
    const customToken = customCartorioStorage.getItem('sb-cartorio-auth-token');
    console.log('üîç [ensureSessionHydration] Token customizado encontrado:', !!customToken);

    // 4. Primeira tentativa: getSession() imediato
    console.log('üîÑ [ensureSessionHydration] ETAPA 1: Tentando getSession...');
    const { data: { session }, error } = await supabase.auth.getSession();
    
    if (error) {
      console.error('‚ùå [ensureSessionHydration] Erro ao obter sess√£o:', error);
    }
    
    if (session?.access_token) {
      console.log('‚úÖ [ensureSessionHydration] Sess√£o hidratada com sucesso!');
      console.log('üîç [ensureSessionHydration] Token present:', session.access_token.substring(0, 20) + '...');
      return true;
    }

    // 5. Segunda tentativa: for√ßar refresh da sess√£o
    console.log('üîÑ [ensureSessionHydration] ETAPA 2: Tentando refresh...');
    const { data: refreshData, error: refreshError } = await supabase.auth.refreshSession();
    
    if (refreshError) {
      console.error('‚ùå [ensureSessionHydration] Erro no refresh:', refreshError);
    } else if (refreshData.session) {
      console.log('‚úÖ [ensureSessionHydration] Sess√£o restaurada via refresh');
      return true;
    }

    // 6. Terceira tentativa: setSession manual se encontrou token
    if (customToken) {
      console.log('üîÑ [ensureSessionHydration] ETAPA 3: Tentando setSession manual...');
      try {
        const parsedToken = JSON.parse(customToken);
        if (parsedToken.access_token && parsedToken.refresh_token) {
          console.log('üîç [ensureSessionHydration] Token v√°lido encontrado, definindo sess√£o...');
          
          const { data: setSessionData, error: setSessionError } = await supabase.auth.setSession({
            access_token: parsedToken.access_token,
            refresh_token: parsedToken.refresh_token
          });
          
          if (setSessionError) {
            console.error('‚ùå [ensureSessionHydration] Erro no setSession:', setSessionError);
          } else if (setSessionData.session) {
            console.log('‚úÖ [ensureSessionHydration] Sess√£o definida manualmente com sucesso');
            return true;
          }
        }
      } catch (parseError) {
        console.error('‚ùå [ensureSessionHydration] Erro ao parsear token:', parseError);
      }
    }
    
    console.warn('‚ö†Ô∏è [ensureSessionHydration] Nenhuma sess√£o v√°lida encontrada ap√≥s todas as tentativas');
    return false;
    
  } catch (error) {
    console.error('‚ùå [ensureSessionHydration] Erro inesperado:', error);
    return false;
  }
};

// Fun√ß√£o para validar JWT com diagn√≥stico aprimorado
export const getValidSession = async () => {
  try {
    console.log('üîç [getValidSession] Iniciando valida√ß√£o com diagn√≥stico aprimorado...');
    
    const { data: { session }, error } = await supabase.auth.getSession();
    
    if (error) {
      console.error('‚ùå [getValidSession] Erro ao obter sess√£o:', error);
      return null;
    }
    
    if (!session) {
      console.warn('‚ö†Ô∏è [getValidSession] Nenhuma sess√£o encontrada');
      
      // Diagn√≥stico adicional com custom storage
      const customToken = customCartorioStorage.getItem('sb-cartorio-auth-token');
      console.log('üîç [getValidSession] CustomStorage tem dados:', !!customToken);
      
      return null;
    }
    
    // VALIDA√á√ÉO CR√çTICA: Analisar o JWT payload
    if (session.access_token) {
      try {
        const jwtPayload = JSON.parse(atob(session.access_token.split('.')[1]));
        
        console.log('üîç [getValidSession] JWT Payload Analysis:', {
          role: jwtPayload.role,
          sub: jwtPayload.sub,
          email: jwtPayload.email,
          exp: jwtPayload.exp,
          iat: jwtPayload.iat,
          aud: jwtPayload.aud,
          tokenValid: jwtPayload.exp > Math.floor(Date.now() / 1000)
        });
        
        // VERIFICA√á√ÉO 1: Token deve ser authenticated
        if (jwtPayload.role !== 'authenticated') {
          console.error('‚ùå [getValidSession] Token n√£o √© authenticated:', jwtPayload.role);
          await supabase.auth.signOut();
          return null;
        }
        
        // VERIFICA√á√ÉO 2: Token deve ter user_id (sub)
        if (!jwtPayload.sub) {
          console.error('‚ùå [getValidSession] Token sem user_id (sub)');
          await supabase.auth.signOut();
          return null;
        }
        
        // VERIFICA√á√ÉO 3: Token n√£o pode estar expirado
        const now = Math.floor(Date.now() / 1000);
        if (jwtPayload.exp <= now) {
          console.warn('‚ö†Ô∏è [getValidSession] Token expirado, tentando refresh...');
          const refreshResult = await supabase.auth.refreshSession();
          
          if (refreshResult.error || !refreshResult.data.session) {
            console.error('‚ùå [getValidSession] Erro no refresh:', refreshResult.error);
            await supabase.auth.signOut();
            return null;
          }
          
          console.log('‚úÖ [getValidSession] Token renovado com sucesso');
          return refreshResult.data.session;
        }
        
        console.log('‚úÖ [getValidSession] Token authenticated v√°lido confirmado');
        
      } catch (parseError) {
        console.error('‚ùå [getValidSession] Erro ao analisar JWT:', parseError);
        await supabase.auth.signOut();
        return null;
      }
    }
    
    return session;
  } catch (error) {
    console.error('‚ùå [getValidSession] Erro inesperado:', error);
    return null;
  }
};

// Fun√ß√£o para verificar se o usu√°rio est√° autenticado
export const isUserAuthenticated = async () => {
  const session = await getValidSession();
  return !!session;
};

// Fun√ß√£o para obter headers de autentica√ß√£o v√°lidos com diagn√≥stico
export const getAuthHeaders = async () => {
  const session = await getValidSession();
  
  if (!session?.access_token) {
    console.error('‚ùå [getAuthHeaders] Token authenticated n√£o dispon√≠vel');
    return {};
  }
  
  const headers = {
    'Authorization': `Bearer ${session.access_token}`,
    'apikey': SUPABASE_PUBLISHABLE_KEY,
    'Content-Type': 'application/json'
  };
  
  console.log('‚úÖ [getAuthHeaders] Headers com token authenticated preparados');
  return headers;
};

// Sistema simplificado de gerenciamento de contexto para cart√≥rios
class CartorioAuthManager {
  private currentToken: string | null = null;

  setContext(token: string) {
    console.log('üîê [CartorioAuth] Configurando contexto para token:', token.substring(0, 20) + '...');
    this.currentToken = token;
  }

  clearContext() {
    console.log('üîê [CartorioAuth] Limpando contexto');
    this.currentToken = null;
  }

  hasValidContext(): boolean {
    return this.currentToken !== null;
  }
}

const cartorioAuthManager = new CartorioAuthManager();

export const setCartorioAuthContext = (token: string) => {
  cartorioAuthManager.setContext(token);
};

export const clearCartorioAuthContext = () => {
  cartorioAuthManager.clearContext();
};

// Fun√ß√£o para executar RPC com valida√ß√£o robusta de sess√£o
export const executeRPCWithCartorioContext = async (rpcName: string, params: any) => {
  console.log(`üîÑ [executeRPC] Executando ${rpcName} com valida√ß√£o robusta...`);
  
  try {
    // Garantir que temos uma sess√£o v√°lida antes de executar
    const session = await getValidSession();
    
    if (!session) {
      console.error(`‚ùå [executeRPC] Sess√£o inv√°lida para ${rpcName}`);
      throw new Error('Sess√£o inv√°lida. Fa√ßa login novamente.');
    }
    
    console.log(`üîç [executeRPC] Executando ${rpcName} com sess√£o v√°lida`);
    
    const { data, error } = await supabase.rpc(rpcName as any, params);
    
    if (error) {
      console.error(`‚ùå [executeRPC] Erro RPC ${rpcName}:`, error);
      throw error;
    }
    
    console.log(`‚úÖ [executeRPC] ${rpcName} executado com sucesso`);
    return data;
  } catch (rpcError) {
    console.error(`‚ùå [executeRPC] Falha na execu√ß√£o de ${rpcName}:`, rpcError);
    throw rpcError;
  }
};
